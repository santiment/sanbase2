defmodule Sanbase.AppNotifications do
  @moduledoc """
  Context for managing Sanbase App (website) notifications.

  Sanbase App Notifications are not to be confused with other types of notifications.

  Notifications in Sanbase are used to nofiy users about various events in the
  Sanbase application (website). These notifications can be:
  - system generated - generated by Santiment and sent to all users,
    for example about maintenance
  - user specific - when a user performs some action like creating a watchlist,
    their followers are notified about it

  To create notifications two steps are needed: emit an event and handle the event.

  To emit an event using the EventEmitter functionality:
    import Sanbase.UserList.EventEmitter, only: [emit_event: 3]
    emit_event({:ok, watchlist}, :create_watchlist, %{} = _extra_args)

  Events are handled by all event subscribers, one of which is the
  Sanbase.EventBus.AppNotificationsSubscriber module. This module listens for all events
  acrross the system and creates notifications when needed.

  To handle an event and create a notification from it, handling for that event needs
  to be added in the Sanbase.EventBus.AppNotificationsSubscriber.handle_event/3 function.
  Read the subscriber module documentation for more details how to create a notification.

  Notification creation process involves creating two separate record types:
  - The notification itself - stored in the `sanbaes_notifications` table, handled by the
    Sanbase.AppNotifications.Notification module
  - One record per user that receives the notification (possibly hundreds/thousands) -
    stored in the `sanbase_notification_user_reads` table, handled by the
    Sanbase.AppNotifications.NotificationReadStatus module. This separation is required as each
    user can mark the notification as read independently. Using two tables avoids data duplication
    and allows for better performance when querying (the notification type, title, content, etc. is stored only once).
  """

  import Ecto.Query

  alias Sanbase.Repo
  alias Sanbase.AppNotifications.Notification
  alias Sanbase.AppNotifications.NotificationReadStatus

  @default_limit 20

  @doc """
  Creates a notification entry.
  """
  @spec create_notification(map()) :: {:ok, Notification.t()} | {:error, Ecto.Changeset.t()}
  def create_notification(attrs) when is_map(attrs) do
    %Notification{}
    |> Notification.changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Creates a notification read status entry linking a user to a notification.
  """
  @spec create_notification_read_status(map()) ::
          {:ok, NotificationReadStatus.t()} | {:error, Ecto.Changeset.t()}
  def create_notification_read_status(attrs) when is_map(attrs) do
    %NotificationReadStatus{}
    |> NotificationReadStatus.changeset(attrs)
    |> Repo.insert()
  end

  @spec notification_read_satatus_changeset(map()) :: Ecto.Changeset.t()
  def notification_read_satatus_changeset(attrs) when is_map(attrs) do
    NotificationReadStatus.changeset(%NotificationReadStatus{}, attrs)
  end

  @spec notification_changeset(map()) :: Ecto.Changeset.t()
  def notification_changeset(attrs) when is_map(attrs) do
    Notification.changeset(%NotificationReadStatus{}, attrs)
  end

  @doc """
  Returns the latest notifications that are visible to the provided user.

  A user has a notification if there is a NotificationReadStatus record for that user_id and notification_id.

  By default returns the latest #{@default_limit} notifications.
  Supports cursor-based pagination via the `:cursor` option.
  """
  @spec list_notifications_for_user(pos_integer(), keyword()) :: [Notification.t()]
  def list_notifications_for_user(user_id, opts \\ []) when is_integer(user_id) do
    limit = Keyword.get(opts, :limit, @default_limit)
    cursor = Keyword.get(opts, :cursor)

    from(n in Notification,
      join: nrs in NotificationReadStatus,
      on: nrs.notification_id == n.id and nrs.user_id == ^user_id,
      where: n.is_deleted == false
    )
    |> maybe_apply_cursor(cursor)
    |> order_by([n], desc: n.inserted_at, desc: n.id)
    |> limit(^limit)
    |> select_merge([_n, nrs], %{read_at: nrs.read_at})
    |> Repo.all()
  end

  @doc """
  Fetches a single notification for the given user with read status.

  A user has a notification if there is a NotificationReadStatus record for that user_id and notification_id.
  """
  @spec get_notification_for_user(pos_integer(), pos_integer()) ::
          {:ok, Notification.t()} | {:error, :not_found}
  def get_notification_for_user(user_id, notification_id)
      when is_integer(user_id) and is_integer(notification_id) do
    from(n in Notification,
      join: nrs in NotificationReadStatus,
      on: nrs.notification_id == n.id and nrs.user_id == ^user_id,
      where: n.id == ^notification_id and n.is_deleted == false
    )
    |> preload([_n, _nrs], [:user])
    |> select_merge([_n, nrs], %{read_at: nrs.read_at})
    |> Repo.one()
    |> case do
      nil -> {:error, :not_found}
      notification -> {:ok, notification}
    end
  end

  @doc """
  Sets the read status of a notification for the given user.
  If is_read is true, sets read_at to now. If false, sets read_at to nil.
  """
  @spec set_read_status(pos_integer(), pos_integer(), boolean()) ::
          {:ok, :updated} | {:error, term()}
  def set_read_status(user_id, notification_id, is_read)
      when is_integer(user_id) and is_integer(notification_id) and is_boolean(is_read) do
    with %Notification{} = notification <- fetch_notification_for_user(user_id, notification_id) do
      # Do not update read_at if it is already set. The read_at is a virutal field
      # populated by fetch_notification_for_user/2
      read_at = if is_read, do: notification.read_at || DateTime.utc_now(:second), else: nil

      from(nrs in NotificationReadStatus,
        where: nrs.user_id == ^user_id and nrs.notification_id == ^notification_id
      )
      |> Repo.update_all(set: [read_at: read_at])

      {:ok, :updated}
    else
      nil -> {:error, :not_found}
    end
  end

  @doc """
  Wraps a list of notifications with cursor information for pagination.
  """
  @spec wrap_with_cursor([Notification.t()]) :: {:ok, map()}
  def wrap_with_cursor([]), do: {:ok, %{notifications: [], cursor: %{}}}

  def wrap_with_cursor(notifications) when is_list(notifications) do
    # The notifications are sorted in descending order by inserted_at
    before_datetime = notifications |> List.last() |> Map.get(:inserted_at)
    after_datetime = notifications |> List.first() |> Map.get(:inserted_at)

    {:ok,
     %{
       notifications: notifications,
       cursor: %{
         before: before_datetime,
         after: after_datetime
       }
     }}
  end

  defp maybe_apply_cursor(query, nil), do: query

  defp maybe_apply_cursor(query, %{type: :before, datetime: datetime}) do
    from(n in query, where: n.inserted_at < ^datetime)
  end

  defp maybe_apply_cursor(query, %{type: :after, datetime: datetime}) do
    from(n in query, where: n.inserted_at > ^datetime)
  end

  defp fetch_notification_for_user(user_id, notification_id) do
    from(n in Notification,
      join: nrs in NotificationReadStatus,
      on: nrs.notification_id == n.id and nrs.user_id == ^user_id,
      where: n.id == ^notification_id and n.is_deleted == false,
      select_merge: %{read_at: nrs.read_at}
    )
    |> Repo.one()
  end
end
