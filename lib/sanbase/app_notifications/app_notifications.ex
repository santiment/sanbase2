defmodule Sanbase.AppNotifications do
  @moduledoc """
  Context for managing Sanbase App (website) notifications.

  Sanbase App Notifications are not to be confused with other types of notifications.

  Notifications in Sanbase are used to notfiy users about various events in the
  Sanbase application (website). These notifications can be:
  - system generated - generated by Santiment and sent to all users,
    for example about maintenance
  - user specific - when a user performs some action like creating a watchlist,
    their followers are notified about it

  To create notifications two steps are needed: emit an event and handle the event.

  To emit an event using the EventEmitter functionality:
    import Sanbase.UserList.EventEmitter, only: [emit_event: 3]
    emit_event({:ok, watchlist}, :create_watchlist, %{} = _extra_args)

  Events are handled by all event subscribers, one of which is the
  Sanbase.EventBus.AppNotificationsSubscriber module. This module listens for all events
  across the system and creates notifications when needed.

  To handle an event and create a notification from it, handling for that event needs
  to be added in the Sanbase.EventBus.AppNotificationsSubscriber.handle_event/3 function.
  Read the subscriber module documentation for more details how to create a notification.

  Notification creation process involves creating two separate record types:
  - The notification itself - stored in the `sanbase_notifications` table, handled by the
    Sanbase.AppNotifications.Notification module
  - One record per user that receives the notification (possibly hundreds/thousands) -
    stored in the `sanbase_notification_user_reads` table, handled by the
    Sanbase.AppNotifications.NotificationReadStatus module. This separation is required as each
    user can mark the notification as read independently. Using two tables avoids data duplication
    and allows for better performance when querying (the notification type, title, content, etc. is stored only once).
  """

  import Ecto.Query

  alias Sanbase.Repo
  alias Sanbase.AppNotifications.Notification
  alias Sanbase.AppNotifications.NotificationReadStatus

  @default_limit 20

  @doc """
  Creates a notification entry.
  """
  @spec create_notification(map()) :: {:ok, Notification.t()} | {:error, Ecto.Changeset.t()}
  def create_notification(attrs) when is_map(attrs) do
    %Notification{}
    |> Notification.changeset(attrs)
    |> Repo.insert()
  end

  @doc """
  Creates a notification read status entry linking a user to a notification.
  """
  @spec create_notification_read_status(map()) ::
          {:ok, NotificationReadStatus.t()} | {:error, Ecto.Changeset.t()}
  def create_notification_read_status(attrs) when is_map(attrs) do
    %NotificationReadStatus{}
    |> NotificationReadStatus.changeset(attrs)
    |> Repo.insert()
  end

  @spec notification_read_status_changeset(map()) :: Ecto.Changeset.t()
  def notification_read_status_changeset(attrs) when is_map(attrs) do
    NotificationReadStatus.changeset(%NotificationReadStatus{}, attrs)
  end

  @doc """
  Return the most recently created notification of `type` for `entity_type`/`entity_id`,
  created by `user_id`.
  """
  @spec last_notification_created_by(atom(), atom() | String.t(), integer(), pos_integer()) ::
          {:ok, Notification.t()} | {:error, :not_found}
  def last_notification_created_by(type, entity_type, entity_id, user_id) do
    query =
      from(n in Notification,
        where:
          n.type == ^to_string(type) and n.entity_type == ^to_string(entity_type) and
            n.entity_id == ^entity_id and
            n.user_id == ^user_id and n.is_deleted == false,
        order_by: [desc: n.inserted_at, desc: n.id],
        limit: 1
      )

    case Repo.one(query) do
      %Notification{} = notification -> {:ok, notification}
      _ -> {:error, :not_found}
    end
  end

  @doc """
  Returns the latest notifications that are visible to the provided user.

  A user has a notification if there is a NotificationReadStatus record for that user_id and notification_id.

  By default returns the latest #{@default_limit} notifications.
  Supports cursor-based pagination via the `:cursor` option.
  """
  @spec list_notifications_for_user(pos_integer(), keyword()) :: [Notification.t()]
  def list_notifications_for_user(user_id, opts \\ []) when is_integer(user_id) do
    limit = Keyword.get(opts, :limit, @default_limit)
    cursor = Keyword.get(opts, :cursor)

    from(nrs in NotificationReadStatus,
      join: n in Notification,
      on: n.id == nrs.notification_id and n.is_deleted == false,
      where: nrs.user_id == ^user_id,
      order_by: [desc: n.inserted_at, desc: n.id],
      select: n,
      select_merge: %{
        read_at: nrs.read_at,
        json_data: fragment("COALESCE(?, '{}')", n.json_data)
      },
      limit: ^limit
    )
    |> maybe_apply_cursor(cursor)
    |> Repo.all()
    # Two-phase load to preload the user and their roles.
    # We select from NotificationReadStatus, but preload the user from Notification
    # Ecto is not happy if you don't select the binding from `from` when there's
    # a preload
    |> Repo.preload(user: [:roles, roles: :role])
  end

  @doc """
  Fetches a single notification for the given user with read status.

  A user has a notification if there is a NotificationReadStatus record for that user_id and notification_id.
  """
  @spec get_notification_for_user(pos_integer(), pos_integer()) ::
          {:ok, Notification.t()} | {:error, :not_found}
  def get_notification_for_user(user_id, notification_id)
      when is_integer(user_id) and is_integer(notification_id) do
    from(n in Notification,
      join: nrs in NotificationReadStatus,
      on: nrs.notification_id == n.id and nrs.user_id == ^user_id,
      where: n.id == ^notification_id and n.is_deleted == false,
      preload: [user: [:roles, roles: :role]]
    )
    |> select_merge([_n, nrs], %{read_at: nrs.read_at})
    |> Repo.one()
    |> case do
      nil -> {:error, :not_found}
      notification -> {:ok, notification}
    end
  end

  @doc """
  Sets the read status of a notification for the given user.
  If is_read is true, sets read_at to now. If false, sets read_at to nil.
  """
  @spec set_read_status(pos_integer(), pos_integer(), boolean()) ::
          {:ok, :updated} | {:error, term()}
  def set_read_status(user_id, notification_id, is_read)
      when is_integer(user_id) and is_integer(notification_id) and is_boolean(is_read) do
    with %Notification{} = notification <- fetch_notification_for_user(user_id, notification_id) do
      # Do not update read_at if it is already set. The read_at is a virtual field
      # populated by fetch_notification_for_user/2
      read_at = if is_read, do: notification.read_at || DateTime.utc_now(:second), else: nil

      from(nrs in NotificationReadStatus,
        where: nrs.user_id == ^user_id and nrs.notification_id == ^notification_id
      )
      |> Repo.update_all(set: [read_at: read_at])

      {:ok, :updated}
    else
      nil -> {:error, :not_found}
    end
  end

  @doc """
  Wraps a list of notifications with cursor information for pagination.
  """
  @spec wrap_with_cursor([Notification.t()]) :: {:ok, map()}
  def wrap_with_cursor([]), do: {:ok, %{notifications: [], cursor: %{}}}

  def wrap_with_cursor(notifications) when is_list(notifications) do
    # The notifications are sorted in descending order by inserted_at
    before_datetime =
      notifications
      |> Enum.min_by(& &1.inserted_at, DateTime)
      |> Map.get(:inserted_at)

    after_datetime =
      notifications
      |> Enum.max_by(& &1.inserted_at, DateTime)
      |> Map.get(:inserted_at)

    {:ok,
     %{
       notifications: notifications,
       cursor: %{
         before: before_datetime,
         after: after_datetime
       }
     }}
  end

  def async_broadcast_websocket_notifications(notification_read_status_list) do
    Task.Supervisor.start_child(Sanbase.TaskSupervisor, fn ->
      Enum.each(notification_read_status_list, fn
        %NotificationReadStatus{user_id: user_id, notification_id: notification_id} ->
          SanbaseWeb.Endpoint.broadcast(
            "notifications:#{user_id}",
            "notification",
            %{notification_id: notification_id, user_id: user_id}
          )
      end)
    end)
  end

  defp maybe_apply_cursor(query, nil), do: query

  defp maybe_apply_cursor(query, %{type: :before, datetime: datetime}) do
    query
    |> where([_notification_read_status, notification], notification.inserted_at < ^datetime)
  end

  defp maybe_apply_cursor(query, %{type: :after, datetime: datetime}) do
    query
    |> where([_notification_read_status, notification], notification.inserted_at > ^datetime)
  end

  defp fetch_notification_for_user(user_id, notification_id) do
    from(n in Notification,
      join: nrs in NotificationReadStatus,
      on: nrs.notification_id == n.id and nrs.user_id == ^user_id,
      where: n.id == ^notification_id and n.is_deleted == false,
      select_merge: %{read_at: nrs.read_at}
    )
    |> Repo.one()
  end
end
