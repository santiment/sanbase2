defmodule Sanbase.AppNotifications do
  @moduledoc """
  Context for managing Sanbase App (website) notifications.

  Sanbase App Notifications are not to be confused with other types of notifications.

  Notifications in Sanbase are used to nofiy users about various events in the
  Sanbase application (website). These notifications can be:
  - system generated - generated by Santiment and sent to all users,
    for example about maintenance
  - user specific - when a user performs some action like creating a watchlist,
    their followers are notified about it

  To create notifications two steps are needed: emit an event and handle the event.

  To emit an event using the EventEmitter functionality:
    import Sanbase.UserList.EventEmitter, only: [emit_event: 3]
    emit_event({:ok, watchlist}, :create_watchlist, %{} = _extra_args)

  Events are handled by all event subscribers, one of which is the
  Sanbase.EventBus.AppNotificationsSubscriber module. This module listens for all events
  acrross the system and creates notifications when needed.

  To handle an event and create a notification from it, handling for that event needs
  to be added in the Sanbase.EventBus.AppNotificationsSubscriber.handle_event/3 function.
  Read the subscriber module documentation for more details how to create a notification.

  Notification creation process involves creating two separate record types:
  - The notification itself - stored in the `sanbaes_notifications` table, handled by the
    Sanbase.AppNotifications.Notification module
  - One record per user that receives the notification (possibly hundreds/thousands) -
    stored in the `sanbase_notification_user_reads` table, handled by the
    Sanbase.AppNotifications.NotificationReadStatus module. This separation is required as each
    user can mark the notification as read independently. Using two tables avoids data duplication
    and allows for better performance when querying (the notification type, title, content, etc. is stored only once).
  """

  import Ecto.Query

  alias Sanbase.Repo
  alias Sanbase.AppNotifications.Notification
  alias Sanbase.AppNotifications.NotificationReadStatus

  @default_limit 20

  @doc """
  Creates a notification entry.
  """
  @spec create_notification(map()) :: {:ok, Notification.t()} | {:error, Ecto.Changeset.t()}
  def create_notification(attrs) when is_map(attrs) do
    %Notification{}
    |> Notification.changeset(attrs)
    |> Repo.insert()
  end

  @spec notification_read_satatus_changeset(map()) :: Ecto.Changeset.t()
  def notification_read_satatus_changeset(attrs) when is_map(attrs) do
    NotificationReadStatus.changeset(%NotificationReadStatus{}, attrs)
  end

  @spec notification_changeset(map()) :: Ecto.Changeset.t()
  def notification_changeset(attrs) when is_map(attrs) do
    Notification.changeset(%NotificationReadStatus{}, attrs)
  end

  @doc """
  Returns the latest notifications that are visible to the provided user.

  By default returns the latest #{@default_limit} notifications.
  """
  @spec list_notifications_for_user(pos_integer(), keyword()) :: [Notification.t()]
  def list_notifications_for_user(user_id, opts \\ []) when is_integer(user_id) do
    limit = Keyword.get(opts, :limit, @default_limit)

    Notification
    |> accessible_notifications_query(user_id)
    |> join(:left, [n], nur in NotificationReadStatus,
      on: nur.notification_id == n.id and nur.user_id == ^user_id
    )
    |> preload([n, _nur], [:user, :actor_user])
    |> order_by([n], desc: n.inserted_at)
    |> limit(^limit)
    |> select_merge([_n, nur], %{read_at: nur.read_at})
    |> Repo.all()
  end

  @doc """
  Marks a notification as read for the given user.
  """
  @spec mark_notification_as_read(pos_integer(), pos_integer()) ::
          {:ok, NotificationReadStatus.t()} | {:error, term()}
  def mark_notification_as_read(user_id, notification_id)
      when is_integer(user_id) and is_integer(notification_id) do
    with %Notification{} <- fetch_notification_for_user(user_id, notification_id),
         args = %{user_id: user_id, notification_id: notification_id, read_at: DateTime.utc_now()},
         changeset <- NotificationReadStatus.changeset(%NotificationReadStatus{}, args),
         {:ok, result} <- upsert_user_read(changeset) do
      {:ok, result}
    else
      nil -> {:error, :not_found}
      {:error, reason} -> {:error, reason}
    end
  end

  defp accessible_notifications_query(query, user_id) do
    from(n in query,
      where: n.is_deleted == false,
      where: n.user_id == ^user_id or n.is_broadcast
    )
  end

  defp fetch_notification_for_user(user_id, notification_id) do
    Notification
    |> accessible_notifications_query(user_id)
    |> where([n], n.id == ^notification_id)
    |> Repo.one()
  end

  defp upsert_user_read(changeset) do
    Repo.insert(changeset, on_conflict: :nothing)
  end
end
