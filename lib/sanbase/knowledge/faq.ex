defmodule Sanbase.Knowledge.Faq do
  alias Sanbase.Repo
  alias Sanbase.Knowledge.FaqEntry
  import Ecto.Query

  def list_entries do
    FaqEntry
    |> order_by(desc: :updated_at)
    |> preload([:tags])
    |> Repo.all()
  end

  def get_entry!(id) do
    Repo.get!(FaqEntry, id) |> Repo.preload(:tags)
  end

  def create_entry(attrs \\ %{}) do
    %FaqEntry{}
    |> FaqEntry.changeset(attrs)
    |> Repo.insert()
    |> maybe_update_embedding()
  end

  def update_entry(%FaqEntry{} = entry, attrs) do
    entry
    |> FaqEntry.changeset(attrs)
    |> Repo.update()
    |> maybe_update_embedding()
  end

  def delete_entry(%FaqEntry{} = entry) do
    Repo.delete(entry)
  end

  def change_entry(%FaqEntry{} = entry, attrs \\ %{}) do
    entry =
      if Map.get(entry, :tags) == %Ecto.Association.NotLoaded{},
        do: %{entry | tags: []},
        else: entry

    FaqEntry.changeset(entry, attrs)
  end

  def answer_question(question) do
    with {:ok, similar_entries} <- find_similar_entries(question),
         :ok <- validate_similar_entries(similar_entries),
         {:ok, combined_text} <- combine_entries(question, similar_entries),
         {:ok, answer} <- Sanbase.OpenAI.Question.ask(combined_text),
         {:ok, formatted_answer} <- format_answer(question, answer, similar_entries) do
      {:ok, formatted_answer}
    end
  end

  def find_similar_entries(user_input, size \\ 5) do
    with {:ok, user_embedding} <- Sanbase.OpenAI.Embedding.generate_embedding(user_input, 1536) do
      query =
        from(
          e in FaqEntry,
          order_by: fragment("embedding <=> ?", ^user_embedding),
          limit: ^size,
          select: %{
            id: e.id,
            question: e.question,
            answer_markdown: e.answer_markdown,
            similarity: fragment("1 - (embedding <=> ?)", ^user_embedding)
          }
        )

      result = Repo.all(query) |> Enum.filter(&(&1.similarity > 0.3))
      {:ok, result}
    else
      {:error, _} = error -> error
    end
  end

  # Private functions
  defp validate_similar_entries([_ | _]), do: :ok

  defp validate_similar_entries([]) do
    # Returns :ok tuple which does not match the :ok in the with pipeline,
    # so it's returned early
    {:ok, "Not enough information in our database to answer this question."}
  end

  defp format_answer(_question, answer, similar_entries) do
    faq_link_bullets =
      Enum.map(similar_entries, fn faq ->
        "- https://santiment.net/faq/#{faq.id}"
      end)

    used_faqs =
      """

      The answer was generated by using the following FAQs:
      #{Enum.join(faq_link_bullets, "\n")}
      end}
      """

    formatted_answer = """
    #{answer}
    #{if false and similar_entries != [], do: used_faqs}
    """

    {:ok, formatted_answer}
  end

  defp combine_entries(question, similar_entries) do
    faq_entries_text =
      Enum.map(similar_entries, fn faq ->
        """
        Question: #{faq.question}
        Answer: #{faq.answer_markdown}
        """
      end)
      |> Enum.join("\n\n")

    combined_text = """
    Act as a professional support. A user of Santiment asked you the following question:
    Question: #{question}

    Use the following FAQ entries from our FAQ database to answer the question in the best
    possible way. Be brief, professional and on point. Skip and introduction, greetings, congratulations
    on the good question, and any other non-question related talking.
    If you are not able to find the answer in the provided questions and answers just answer "I cannot answer".

    Format your answer in markdown. Use lists, headings, bold and italics if necessary.
    When providing links, use the markdown syntax for links.
    For code, use code blocks.

    #{faq_entries_text}
    """

    {:ok, combined_text}
  end

  defp maybe_update_embedding({:ok, %FaqEntry{} = entry} = result) do
    Task.Supervisor.async_nolink(Sanbase.TaskSupervisor, fn ->
      do_update_embedding(entry)
    end)

    result
  end

  defp maybe_update_embedding({:error, _} = error), do: error

  defp do_update_embedding(%FaqEntry{} = entry) do
    text = """
    Question: #{entry.question}
    Answer: #{entry.answer_markdown}
    """

    case Sanbase.OpenAI.Embedding.generate_embedding(text, 1536) do
      {:ok, embedding} ->
        entry
        |> Ecto.Changeset.change(embedding: embedding)
        |> Repo.update()
        |> case do
          {:ok, updated_entry} -> {:ok, updated_entry}
          {:error, _} -> {:ok, entry}
        end

      {:error, _} ->
        {:ok, entry}
    end
  end
end
