defmodule Sanbase.Knowledge.Faq do
  alias Sanbase.Repo
  alias Sanbase.Knowledge.FaqEntry
  import Ecto.Query

  def list_entries do
    FaqEntry
    |> order_by(desc: :updated_at)
    |> preload([:tags])
    |> Repo.all()
  end

  def get_entry!(id) do
    Repo.get!(FaqEntry, id) |> Repo.preload(:tags)
  end

  def create_entry(attrs \\ %{}) do
    %FaqEntry{}
    |> FaqEntry.changeset(attrs)
    |> Repo.insert()
    |> maybe_update_embedding()
  end

  def update_entry(%FaqEntry{} = entry, attrs) do
    entry
    |> FaqEntry.changeset(attrs)
    |> Repo.update()
    |> maybe_update_embedding()
  end

  def delete_entry(%FaqEntry{} = entry) do
    Repo.delete(entry)
  end

  def change_entry(%FaqEntry{} = entry, attrs \\ %{}) do
    entry =
      if Map.get(entry, :tags) == %Ecto.Association.NotLoaded{},
        do: %{entry | tags: []},
        else: entry

    FaqEntry.changeset(entry, attrs)
  end

  def answer_question(question) do
    with {:ok, embedding} <- Sanbase.AI.Embedding.generate_embeddings([user_input], 1536),
         {:ok, similar_entries} <- find_similar_entries(embedding),
         :ok <- validate_similar_entries(similar_entries),
         {:ok, combined_text} <- combine_entries(question, similar_entries),
         # {:ok, combined_text} <- add_similar_insight_to_context(embedding, combined_text),
         {:ok, answer} <- Sanbase.OpenAI.Question.ask(combined_text),
         {:ok, formatted_answer} <- format_answer(question, answer, similar_entries) do
      {:ok, formatted_answer}
    end
  end

  def find_similar_entries(user_embedding, size \\ 5) do
    query =
      from(
        e in FaqEntry,
        order_by: fragment("embedding <=> ?", ^user_embedding),
        limit: ^size,
        select: %{
          id: e.id,
          question: e.question,
          answer_markdown: e.answer_markdown,
          similarity: fragment("1 - (embedding <=> ?)", ^user_embedding)
        }
      )

    result = Repo.all(query)
    {:ok, result}
  end

  # Private functions

  def add_similar_insight_to_context(embedding, combined_text) do
    with {:ok, [%{id: similar_insight_id}]} <-
           Sanbase.Insight.Post.find_most_similar_insights(embedding, 1) do
      similar_insight = Sanbase.Insight.Post.by_id!(similar_insight_id, preload?: false)
      insight_markdown_text = Htmd.convert!(similar_insight.text)

      combined_text =
        combined_text <>
          """
            <Most_Similar_Santiment_Insight>
            #{insight_markdown_text}
          </Most_Similar_Santiment_Insight>
          """

      {:ok, combined_text}
    end
  end

  defp validate_similar_entries([_ | _]), do: :ok

  defp validate_similar_entries([]) do
    # Returns :ok tuple which does not match the :ok in the with pipeline,
    # so it's returned early
    {:ok, "Not enough information in our database to answer this question."}
  end

  defp format_answer(_question, answer, similar_entries) do
    faq_link_bullets =
      Enum.map(similar_entries, fn faq ->
        "- https://santiment.net/faq/#{faq.id}"
      end)

    used_faqs =
      """

      The answer was generated by using the following FAQs:
      #{Enum.join(faq_link_bullets, "\n")}
      end}
      """

    formatted_answer = """
    #{answer}
    #{if false and similar_entries != [], do: used_faqs}
    """

    {:ok, formatted_answer}
  end

  defp combine_entries(question, similar_entries) do
    faq_entries_text =
      Enum.map(similar_entries, fn faq ->
        """
        Question: #{faq.question}
        Answer: #{faq.answer_markdown}
        """
      end)
      |> Enum.join("\n\n")

    combined_text = """
    <Role>
    You are an expert Support Specialist working at Santiment. You have extensive experience in crypto, programming, trading, technical and non-technical support.
    You possess exceptional communication skills and can explain complex technical concepts in simple terms.
    </Role>

    <Instructions>
    1. Use the provided FAQ entries to answer the user's question.
    2. Be brief, professional and on point. Skip any introduction, greetings, congratulations.
    3. If you are not able to provide an answer based on the provided FAQ entries, just say that you cannot answer this question
    4. Format your answer in markdown. Use lists, headings, bold and italics if necessary. When providing links, use the markdown syntax for links.
    5. For code, use code blocks.
    6. If something looks similar, but not exactly the same, generate an answer that gives this answer. Be specific that this answer is taken from a slightly different context. Suggest contacting Santiment Support for further clarifications.
    </Instructions>

    <FAQ_Entries>
    #{faq_entries_text}
    </FAQ_Entries>

    <User_Input>
    Question: #{question}
    </User_Input>
    """

    {:ok, combined_text}
  end

  defp maybe_update_embedding({:ok, %FaqEntry{} = entry} = result) do
    Task.Supervisor.async_nolink(Sanbase.TaskSupervisor, fn ->
      do_update_embedding(entry)
    end)

    result
  end

  defp maybe_update_embedding({:error, _} = error), do: error

  defp do_update_embedding(%FaqEntry{} = entry) do
    text = """
    Question: #{entry.question}
    Answer: #{entry.answer_markdown}
    """

    case Sanbase.AI.Embedding.generate_embeddings([text], 1536) do
      {:ok, [embedding]} ->
        entry
        |> Ecto.Changeset.change(embedding: embedding)
        |> Repo.update()
        |> case do
          {:ok, updated_entry} -> {:ok, updated_entry}
          {:error, _} -> {:ok, entry}
        end

      {:error, _} ->
        {:ok, entry}
    end
  end
end
