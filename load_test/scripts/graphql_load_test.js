import http from "k6/http";
import { check, sleep } from "k6";
import { SharedArray } from "k6/data";
import { Rate, Trend } from "k6/metrics";

// Custom metrics
const errorRate = new Rate("graphql_errors");
const queryDuration = new Trend("graphql_query_duration", true);

// Load API keys from JSON file generated by mix load_test.setup
const apikeys = new SharedArray("apikeys", function () {
  return JSON.parse(open("../data/apikeys.json"));
});

// Configuration
const BASE_URL = __ENV.BASE_URL || "http://localhost:4000";
const GRAPHQL_URL = `${BASE_URL}/graphql`;

// Scenarios
const scenarios = {
  smoke: {
    executor: "constant-vus",
    vus: 2,
    duration: "30s",
  },
  load: {
    executor: "constant-vus",
    vus: 20,
    duration: "2m",
  },
  stress: {
    executor: "ramping-vus",
    startVUs: 0,
    stages: [
      { duration: "30s", target: 10 },
      { duration: "1m", target: 50 },
      { duration: "1m", target: 50 },
      { duration: "30s", target: 0 },
    ],
  },
};

const selectedScenario = __ENV.SCENARIO || "smoke";

export const options = {
  scenarios: {
    default: scenarios[selectedScenario],
  },
  thresholds: {
    http_req_duration: ["p(95)<5000"],
    graphql_errors: ["rate<0.1"],
  },
};

// --- Static Data ---

// Try to load slugs from file generated by mix load_test.seed_projects.
// Falls back to a hardcoded list if the file doesn't exist.
let SLUGS;
try {
  SLUGS = JSON.parse(open("../data/slugs.json"));
} catch (_e) {
  SLUGS = [
    "bitcoin", "ethereum", "solana", "cardano", "chainlink",
    "litecoin", "avalanche", "polkadot-new", "dogecoin", "tron",
    "xrp", "binance-coin", "monero", "stellar", "cosmos",
    "uniswap", "aave", "near-protocol", "aptos", "sui",
    "tether", "usd-coin", "multi-collateral-dai", "shiba-inu",
    "pepe", "toncoin", "fantom", "render", "file-coin",
    "algorand", "ethereum-classic", "internet-computer", "ondo-finance",
    "bitcoin-cash", "zcash", "hedera-hashgraph", "kaspa", "bittensor",
  ];
}

// Slug-based on-chain / financial metrics (plain slug selector only).
// NOTE: amount_in_top_holders needs holdersCount selector — handled
// separately in queryGetMetricHolders. Do NOT add it here.
const SLUG_METRICS = [
  "daily_active_addresses",
  "transaction_volume",
  "exchange_inflow",
  "exchange_outflow",
  "network_growth",
  "nvt",
  "mvrv_usd",
  "circulation",
  "mean_age",
  "active_deposits",
  "whale_transaction_count_100k_usd_to_inf",
  "percent_of_total_supply_on_exchanges",
  "supply_on_exchanges",
  "supply_outside_exchanges",
  "age_consumed",
  "velocity",
  "realized_value_usd",
  "mean_realized_price_usd",
  "mean_dollar_invested_age",
  "dev_activity_1d",
];

// Social metrics — candidates for text selector (validated at warmup)
const SOCIAL_METRICS = [
  "social_volume_total",
  "social_volume_telegram",
  "social_volume_reddit",
  "social_volume_twitter",
  "social_dominance_total",
  "community_messages_count_total",
  "community_messages_count_telegram",
];

const SOCIAL_TEXT_QUERIES = [
  "bitcoin OR btc",
  "ethereum OR eth",
  "solana OR sol",
  "cardano OR ada",
  "defi",
  "nft",
  "layer2 OR L2",
  "stablecoin",
  "airdrop",
  "whale",
];

// GitHub metrics — candidates for organization selector (validated at warmup)
const GITHUB_METRICS = [
  "dev_activity",
  "github_activity",
];

const GITHUB_ORGS = [
  "bitcoin", "ethereum", "solana-labs", "cardano-foundation",
  "smartcontractkit", "aave", "uniswap", "near", "cosmos",
  "paritytech", "ava-labs", "aptos-labs", "MystenLabs",
  "opentensor", "filecoin-project", "algorand", "stellar",
];

// Day ranges and intervals for randomization
const DAY_RANGES = [1, 2, 3, 7, 14, 30, 60, 90, 180, 365];

// Metrics safe to use on allProjects (available for nearly all slugs).
// Do NOT include metrics with limited slug support here (e.g.
// amount_in_top_holders, whale_transaction_count_*) because the query
// applies the metric to every project in the page.
const BROAD_METRICS = [
  "daily_active_addresses",
  "transaction_volume",
  "exchange_inflow",
  "nvt",
  "mvrv_usd",
  "dev_activity",
  "network_growth",
  "mean_age",
  "circulation",
];

// All metrics we want to warm up (fetch availableSlugs + availableSelectors)
const ALL_METRICS = [
  ...new Set([
    ...SLUG_METRICS,
    ...SOCIAL_METRICS,
    ...GITHUB_METRICS,
    ...BROAD_METRICS,
    "amount_in_top_holders",
  ]),
];

// --- Helpers ---

function randomFrom(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function daysAgo(n) {
  const d = new Date();
  d.setDate(d.getDate() - n);
  return d.toISOString();
}

function intervalForDays(days) {
  if (days <= 1) return randomFrom(["5m", "15m", "30m"]);
  if (days <= 7) return randomFrom(["30m", "1h", "2h"]);
  if (days <= 30) return randomFrom(["1h", "2h", "4h", "8h"]);
  if (days <= 90) return randomFrom(["4h", "8h", "1d"]);
  return randomFrom(["1d", "7d"]);
}

function gql(apikey, query) {
  return http.post(GRAPHQL_URL, JSON.stringify({ query }), {
    headers: {
      "Content-Type": "application/json",
      Authorization: `Apikey ${apikey}`,
    },
  });
}

// --- Setup: fetch availableSlugs + availableSelectors per metric ---

export function setup() {
  const apikey = apikeys[0];
  // metric -> list of slugs (only for metrics that support slug selector)
  const metricSlugs = {};
  // metric -> set of supported selector names (e.g. ["slug", "text", "organization"])
  const metricSelectors = {};

  console.log(`Warmup: fetching metadata for ${ALL_METRICS.length} metrics...`);

  for (const metric of ALL_METRICS) {
    const query = `{
      getMetric(metric: "${metric}") {
        metadata {
          availableSlugs
          availableSelectors
        }
      }
    }`;

    const res = gql(apikey, query);

    try {
      const body = JSON.parse(res.body);
      const metadata = body.data?.getMetric?.metadata;

      if (!metadata) {
        console.log(`  ${metric}: no metadata (skipped)`);
        continue;
      }

      // Store available selectors
      const selectors = metadata.availableSelectors || [];
      metricSelectors[metric] = selectors;

      // Store available slugs (intersected with our known set)
      const slugs = metadata.availableSlugs;
      if (slugs && slugs.length > 0) {
        const known = new Set(SLUGS);
        const available = slugs.filter((s) => known.has(s));
        if (available.length > 0) {
          metricSlugs[metric] = available;
        }
      }

      const slugCount = metricSlugs[metric] ? metricSlugs[metric].length : 0;
      console.log(`  ${metric}: ${slugCount} slugs, selectors=[${selectors.join(",")}]`);
    } catch (_e) {
      console.log(`  ${metric}: error fetching metadata (skipped)`);
    }
  }

  console.log("Warmup complete.");
  return { metricSlugs, metricSelectors };
}

// --- Query Definitions ---
// Each function takes `data` (setup output) so it can look up valid slugs/selectors

function queryAllProjects(_data) {
  const page = randomInt(1, 5);
  const pageSize = randomFrom([10, 20, 50]);
  return {
    name: "allProjects",
    query: `{
      allProjects(page: ${page}, pageSize: ${pageSize}) {
        slug
        name
        ticker
        marketcapUsd
      }
    }`,
  };
}

function queryAllProjectsWithAggregated(data) {
  // Only use metrics confirmed to have slug selector and broad slug coverage
  const available = BROAD_METRICS.filter(
    (m) => data.metricSlugs[m] && hasSelector(data, m, "slug"),
  );
  if (available.length === 0) return queryCurrentUser(data);

  const metric = randomFrom(available);
  const days = randomFrom([7, 30, 90]);
  return {
    name: "allProjects_aggregated",
    query: `{
      allProjects(page: 1, pageSize: 10) {
        slug
        name
        ticker
        aggregatedTimeseriesData(
          metric: "${metric}"
          from: "${daysAgo(days)}"
          to: "${daysAgo(0)}"
        )
      }
    }`,
  };
}

function queryProjectBySlug(_data) {
  const slug = randomFrom(SLUGS);
  return {
    name: "projectBySlug",
    query: `{
      projectBySlug(slug: "${slug}") {
        slug
        name
        ticker
        description
        marketcapUsd
        infrastructure
        availableMetrics
      }
    }`,
  };
}

function queryGetMetricMetadata(_data) {
  const metric = randomFrom([...SLUG_METRICS, ...SOCIAL_METRICS, ...GITHUB_METRICS]);
  return {
    name: "getMetric_metadata",
    query: `{
      getMetric(metric: "${metric}") {
        metadata {
          metric
          defaultAggregation
          minInterval
          dataType
        }
      }
    }`,
  };
}

function queryGetMetricTimeseries(data) {
  const available = SLUG_METRICS.filter(
    (m) => data.metricSlugs[m] && hasSelector(data, m, "slug"),
  );
  if (available.length === 0) return queryCurrentUser(data);

  const metric = randomFrom(available);
  const slug = randomFrom(data.metricSlugs[metric]);
  const days = randomFrom(DAY_RANGES);
  const interval = intervalForDays(days);
  return {
    name: "getMetric_timeseries",
    query: `{
      getMetric(metric: "${metric}") {
        timeseriesData(
          selector: { slug: "${slug}" }
          from: "${daysAgo(days)}"
          to: "${daysAgo(0)}"
          interval: "${interval}"
        ) {
          datetime
          value
        }
      }
    }`,
  };
}

function queryGetMetricAggregated(data) {
  const available = SLUG_METRICS.filter(
    (m) => data.metricSlugs[m] && hasSelector(data, m, "slug"),
  );
  if (available.length === 0) return queryCurrentUser(data);

  const metric = randomFrom(available);
  const slug = randomFrom(data.metricSlugs[metric]);
  const days = randomFrom(DAY_RANGES);
  return {
    name: "getMetric_aggregated",
    query: `{
      getMetric(metric: "${metric}") {
        aggregatedTimeseriesData(
          selector: { slug: "${slug}" }
          from: "${daysAgo(days)}"
          to: "${daysAgo(0)}"
        )
      }
    }`,
  };
}

function queryGetMetricSocial(data) {
  const available = SOCIAL_METRICS.filter((m) => hasSelector(data, m, "text"));
  if (available.length === 0) return queryCurrentUser(data);

  const metric = randomFrom(available);
  const text = randomFrom(SOCIAL_TEXT_QUERIES);
  const days = randomFrom([1, 3, 7, 14, 30]);
  const interval = intervalForDays(days);
  return {
    name: "getMetric_social",
    query: `{
      getMetric(metric: "${metric}") {
        timeseriesData(
          selector: { text: "${text}" }
          from: "${daysAgo(days)}"
          to: "${daysAgo(0)}"
          interval: "${interval}"
        ) {
          datetime
          value
        }
      }
    }`,
  };
}

function queryGetMetricGithub(data) {
  const available = GITHUB_METRICS.filter((m) => hasSelector(data, m, "organization"));
  if (available.length === 0) return queryCurrentUser(data);

  const metric = randomFrom(available);
  const org = randomFrom(GITHUB_ORGS);
  const days = randomFrom([7, 30, 90, 180, 365]);
  const interval = intervalForDays(days);
  return {
    name: "getMetric_github",
    query: `{
      getMetric(metric: "${metric}") {
        timeseriesData(
          selector: { organization: "${org}" }
          from: "${daysAgo(days)}"
          to: "${daysAgo(0)}"
          interval: "${interval}"
        ) {
          datetime
          value
        }
      }
    }`,
  };
}

function queryGetMetricHolders(data) {
  if (!hasSelector(data, "amount_in_top_holders", "slug")) return queryCurrentUser(data);

  const slugs = data.metricSlugs["amount_in_top_holders"];
  if (!slugs || slugs.length === 0) return queryCurrentUser(data);

  const slug = randomFrom(slugs);
  const holdersCount = randomFrom([10, 50, 100]);
  const days = randomFrom([7, 30, 90, 180]);
  const interval = intervalForDays(days);
  return {
    name: "getMetric_holders",
    query: `{
      getMetric(metric: "amount_in_top_holders") {
        timeseriesData(
          selector: { slug: "${slug}", holdersCount: ${holdersCount} }
          from: "${daysAgo(days)}"
          to: "${daysAgo(0)}"
          interval: "${interval}"
        ) {
          datetime
          value
        }
      }
    }`,
  };
}

function queryCurrentUser(_data) {
  return {
    name: "currentUser",
    query: `{ currentUser { id email username } }`,
  };
}

// Check if a metric supports a given selector based on warmup data
function hasSelector(data, metric, selectorName) {
  const selectors = data.metricSelectors[metric];
  return selectors && selectors.includes(selectorName);
}

// Weighted query selection — currentUser gets extra weight, metric queries dominate
const queryFunctions = [
  queryAllProjects,
  queryAllProjects,
  queryAllProjectsWithAggregated,
  queryAllProjectsWithAggregated,
  queryProjectBySlug,
  queryProjectBySlug,
  queryProjectBySlug,
  queryGetMetricMetadata,
  queryGetMetricTimeseries,
  queryGetMetricTimeseries,
  queryGetMetricTimeseries,
  queryGetMetricTimeseries,
  queryGetMetricAggregated,
  queryGetMetricAggregated,
  queryGetMetricSocial,
  queryGetMetricSocial,
  queryGetMetricGithub,
  queryGetMetricGithub,
  queryGetMetricHolders,
  queryCurrentUser,
  queryCurrentUser,
  queryCurrentUser,
];

// --- Main Test ---

export default function (data) {
  // Round-robin API key by VU id
  const apikey = apikeys[(__VU - 1) % apikeys.length];

  // Pick a random query (weighted), passing setup data for slug lookup
  const { name, query } = randomFrom(queryFunctions)(data);

  const params = {
    headers: {
      "Content-Type": "application/json",
      Authorization: `Apikey ${apikey}`,
    },
    tags: { query_name: name },
  };

  const payload = JSON.stringify({ query });

  const res = http.post(GRAPHQL_URL, payload, params);

  queryDuration.add(res.timings.duration, { query_name: name });

  const success = check(
    res,
    {
      "status is 200": (r) => r.status === 200,
      "no errors in body": (r) => {
        try {
          const body = JSON.parse(r.body);
          return !body.errors || body.errors.length === 0;
        } catch (_e) {
          return false;
        }
      },
    },
    { query_name: name },
  );

  errorRate.add(!success);

  sleep(Math.random() * 0.5 + 0.1);
}
