import http from "k6/http";
import { check, sleep } from "k6";
import { SharedArray } from "k6/data";
import { Rate, Trend } from "k6/metrics";

// Custom metrics
const errorRate = new Rate("graphql_errors");
const queryDuration = new Trend("graphql_query_duration", true);

// Load API keys from JSON file generated by mix load_test.setup
const apikeys = new SharedArray("apikeys", function () {
  return JSON.parse(open("../data/apikeys.json"));
});

// Configuration
const BASE_URL = __ENV.BASE_URL || "http://localhost:4000";
const GRAPHQL_URL = `${BASE_URL}/graphql`;

// Scenarios
const scenarios = {
  smoke: {
    executor: "constant-vus",
    vus: 2,
    duration: "30s",
  },
  load: {
    executor: "constant-vus",
    vus: 20,
    duration: "2m",
  },
  stress: {
    executor: "ramping-vus",
    startVUs: 0,
    stages: [
      { duration: "30s", target: 10 },
      { duration: "1m", target: 50 },
      { duration: "1m", target: 50 },
      { duration: "30s", target: 0 },
    ],
  },
};

const selectedScenario = __ENV.SCENARIO || "smoke";

export const options = {
  scenarios: {
    default: scenarios[selectedScenario],
  },
  thresholds: {
    http_req_duration: ["p(95)<5000"],
    graphql_errors: ["rate<0.1"],
  },
};

// --- Data ---

const SLUGS = [
  "bitcoin", "ethereum", "solana", "cardano", "chainlink",
  "litecoin", "avalanche", "polkadot-new", "dogecoin", "tron",
  "xrp", "binance-coin", "monero", "stellar", "cosmos",
  "uniswap", "aave", "near-protocol", "aptos", "sui",
  "tether", "usd-coin", "multi-collateral-dai", "shiba-inu",
  "pepe", "toncoin", "fantom", "render", "file-coin",
  "algorand", "ethereum-classic", "internet-computer", "ondo-finance",
  "bitcoin-cash", "zcash", "hedera-hashgraph", "kaspa", "bittensor",
];

// Slug-based on-chain / financial metrics
const SLUG_METRICS = [
  "daily_active_addresses",
  "transaction_volume",
  "exchange_inflow",
  "exchange_outflow",
  "network_growth",
  "nvt",
  "mvrv_usd",
  "circulation",
  "mean_age",
  "active_deposits",
  "whale_transaction_count_100k_usd_to_inf",
  "amount_in_top_holders",
  "percent_of_total_supply_on_exchanges",
  "supply_on_exchanges",
  "supply_outside_exchanges",
  "age_consumed",
  "velocity",
  "realized_value_usd",
  "mean_realized_price_usd",
  "mean_dollar_invested_age",
  "dev_activity_1d",
];

// Social metrics that use text selector
const SOCIAL_METRICS = [
  "social_volume_total",
  "social_volume_telegram",
  "social_volume_reddit",
  "social_volume_twitter",
  "social_dominance_total",
  "community_messages_count_total",
  "community_messages_count_telegram",
];

const SOCIAL_TEXT_QUERIES = [
  "bitcoin OR btc",
  "ethereum OR eth",
  "solana OR sol",
  "cardano OR ada",
  "defi",
  "nft",
  "layer2 OR L2",
  "stablecoin",
  "airdrop",
  "whale",
];

// GitHub metrics that use organization selector
const GITHUB_METRICS = [
  "dev_activity",
  "github_activity",
];

const GITHUB_ORGS = [
  "bitcoin", "ethereum", "solana-labs", "cardano-foundation",
  "smartcontractkit", "aave", "uniswap", "near", "cosmos",
  "paritytech", "ava-labs", "aptos-labs", "MystenLabs",
  "opentensor", "filecoin-project", "algorand", "stellar",
];

// Day ranges and intervals for randomization
const DAY_RANGES = [1, 2, 3, 7, 14, 30, 60, 90, 180, 365];
const INTERVALS = ["5m", "15m", "30m", "1h", "2h", "4h", "8h", "1d", "7d"];

const AGGREGATED_METRICS = [
  "daily_active_addresses",
  "transaction_volume",
  "exchange_inflow",
  "nvt",
  "mvrv_usd",
  "dev_activity",
  "network_growth",
  "mean_age",
  "circulation",
];

// --- Helpers ---

function randomFrom(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
}

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function daysAgo(n) {
  const d = new Date();
  d.setDate(d.getDate() - n);
  return d.toISOString();
}

function intervalForDays(days) {
  if (days <= 1) return randomFrom(["5m", "15m", "30m"]);
  if (days <= 7) return randomFrom(["30m", "1h", "2h"]);
  if (days <= 30) return randomFrom(["1h", "2h", "4h", "8h"]);
  if (days <= 90) return randomFrom(["4h", "8h", "1d"]);
  return randomFrom(["1d", "7d"]);
}

// --- Query Definitions ---

function queryAllProjects() {
  const page = randomInt(1, 5);
  const pageSize = randomFrom([10, 20, 50]);
  return {
    name: "allProjects",
    query: `{
      allProjects(page: ${page}, pageSize: ${pageSize}) {
        slug
        name
        ticker
        marketcapUsd
      }
    }`,
  };
}

function queryAllProjectsWithAggregated() {
  const metric = randomFrom(AGGREGATED_METRICS);
  const days = randomFrom([7, 30, 90]);
  return {
    name: "allProjects_aggregated",
    query: `{
      allProjects(page: 1, pageSize: 10) {
        slug
        name
        ticker
        aggregatedTimeseriesData(
          metric: "${metric}"
          from: "${daysAgo(days)}"
          to: "${daysAgo(0)}"
        )
      }
    }`,
  };
}

function queryProjectBySlug() {
  const slug = randomFrom(SLUGS);
  return {
    name: "projectBySlug",
    query: `{
      projectBySlug(slug: "${slug}") {
        slug
        name
        ticker
        description
        marketcapUsd
        infrastructure
        availableMetrics
      }
    }`,
  };
}

function queryGetMetricMetadata() {
  const metric = randomFrom([...SLUG_METRICS, ...SOCIAL_METRICS, ...GITHUB_METRICS]);
  return {
    name: "getMetric_metadata",
    query: `{
      getMetric(metric: "${metric}") {
        metadata {
          metric
          defaultAggregation
          minInterval
          dataType
        }
      }
    }`,
  };
}

function queryGetMetricTimeseries() {
  const slug = randomFrom(SLUGS);
  const metric = randomFrom(SLUG_METRICS);
  const days = randomFrom(DAY_RANGES);
  const interval = intervalForDays(days);
  return {
    name: "getMetric_timeseries",
    query: `{
      getMetric(metric: "${metric}") {
        timeseriesData(
          selector: { slug: "${slug}" }
          from: "${daysAgo(days)}"
          to: "${daysAgo(0)}"
          interval: "${interval}"
        ) {
          datetime
          value
        }
      }
    }`,
  };
}

function queryGetMetricAggregated() {
  const slug = randomFrom(SLUGS);
  const metric = randomFrom(SLUG_METRICS);
  const days = randomFrom(DAY_RANGES);
  return {
    name: "getMetric_aggregated",
    query: `{
      getMetric(metric: "${metric}") {
        aggregatedTimeseriesData(
          selector: { slug: "${slug}" }
          from: "${daysAgo(days)}"
          to: "${daysAgo(0)}"
        )
      }
    }`,
  };
}

function queryGetMetricSocial() {
  const metric = randomFrom(SOCIAL_METRICS);
  const text = randomFrom(SOCIAL_TEXT_QUERIES);
  const days = randomFrom([1, 3, 7, 14, 30]);
  const interval = intervalForDays(days);
  return {
    name: "getMetric_social",
    query: `{
      getMetric(metric: "${metric}") {
        timeseriesData(
          selector: { text: "${text}" }
          from: "${daysAgo(days)}"
          to: "${daysAgo(0)}"
          interval: "${interval}"
        ) {
          datetime
          value
        }
      }
    }`,
  };
}

function queryGetMetricGithub() {
  const metric = randomFrom(GITHUB_METRICS);
  const org = randomFrom(GITHUB_ORGS);
  const days = randomFrom([7, 30, 90, 180, 365]);
  const interval = intervalForDays(days);
  return {
    name: "getMetric_github",
    query: `{
      getMetric(metric: "${metric}") {
        timeseriesData(
          selector: { organization: "${org}" }
          from: "${daysAgo(days)}"
          to: "${daysAgo(0)}"
          interval: "${interval}"
        ) {
          datetime
          value
        }
      }
    }`,
  };
}

function queryGetMetricHolders() {
  const slug = randomFrom(SLUGS.slice(0, 15));
  const holdersCount = randomFrom([10, 50, 100]);
  const days = randomFrom([7, 30, 90, 180]);
  const interval = intervalForDays(days);
  return {
    name: "getMetric_holders",
    query: `{
      getMetric(metric: "amount_in_top_holders") {
        timeseriesData(
          selector: { slug: "${slug}", holdersCount: ${holdersCount} }
          from: "${daysAgo(days)}"
          to: "${daysAgo(0)}"
          interval: "${interval}"
        ) {
          datetime
          value
        }
      }
    }`,
  };
}

function queryCurrentUser() {
  return {
    name: "currentUser",
    query: `{ currentUser { id email username } }`,
  };
}

// Weighted query selection â€” currentUser gets extra weight, metric queries dominate
const queryFunctions = [
  queryAllProjects,
  queryAllProjects,
  queryAllProjectsWithAggregated,
  queryAllProjectsWithAggregated,
  queryProjectBySlug,
  queryProjectBySlug,
  queryProjectBySlug,
  queryGetMetricMetadata,
  queryGetMetricTimeseries,
  queryGetMetricTimeseries,
  queryGetMetricTimeseries,
  queryGetMetricTimeseries,
  queryGetMetricAggregated,
  queryGetMetricAggregated,
  queryGetMetricSocial,
  queryGetMetricSocial,
  queryGetMetricGithub,
  queryGetMetricGithub,
  queryGetMetricHolders,
  queryCurrentUser,
  queryCurrentUser,
  queryCurrentUser,
];

// --- Main Test ---

export default function () {
  // Round-robin API key by VU id
  const apikey = apikeys[(__VU - 1) % apikeys.length];

  // Pick a random query (weighted)
  const { name, query } = randomFrom(queryFunctions)();

  const params = {
    headers: {
      "Content-Type": "application/json",
      Authorization: `Apikey ${apikey}`,
    },
    tags: { query_name: name },
  };

  const payload = JSON.stringify({ query });

  const res = http.post(GRAPHQL_URL, payload, params);

  queryDuration.add(res.timings.duration, { query_name: name });

  const success = check(
    res,
    {
      "status is 200": (r) => r.status === 200,
      "no errors in body": (r) => {
        try {
          const body = JSON.parse(r.body);
          return !body.errors || body.errors.length === 0;
        } catch (_e) {
          return false;
        }
      },
    },
    { query_name: name },
  );

  errorRate.add(!success);

  sleep(Math.random() * 0.5 + 0.1);
}
